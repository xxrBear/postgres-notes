## 查询语句

### 简单的查询语句

```sql
SELECT * FROM users;
```

这是一个最简单的查询语句，它代表着查询`users`表的全部字段数据，`*`在这里是通配符的意思，代表着表的全部字段，如果想要查询单独的字段，可以直接列出这个字段的名称，例如：

```sql
SELECT name FROM users;
```

这个语句就只查询`users`表的`name`字段的所有值

### 分组语句

- 查看 example.sql 文件获取演示数据

```sql
SELECT region, product, SUM(sales)
FROM orders
GROUP BY region, product;
```

按 (region, product) 分组，每个地区、每个产品一行。这就是最基础的二维分组统计

### 高级分组

在 PostgreSQL 里，`GROUPING SETS`、`CUBE` 和 `ROLLUP` 都是高级分组的工具，用来一次性生成多种 `GROUP BY` 结果，避免写一堆 `UNION ALL`

**逐级汇总**

ROLLUP 子句，用于逐级向上汇总，常用于分层小计或总计

```sql
SELECT region, product, SUM(sales)
FROM orders
GROUP BY ROLLUP(region, product)
ORDER BY region, product;
```

等价于：

```sql
GROUP BY GROUPING SETS (
    (region, product),   -- 明细
    (region),            -- 按区域
    ()                   -- 总计
);
```

特点：它会自动按参数顺序逐层聚合

**所有维度汇总**

CUBE 子句常用于维度的所有组合

```sql
SELECT region, product, SUM(sales)
FROM orders
GROUP BY CUBE(region, product);
```

等价于：

```sql
GROUP BY GROUPING SETS (
    (region, product),   -- 明细
    (region),            -- 按区域
    (product),           -- 按产品
    ()                   -- 总计
);
```

如果你有 N 个维度，`CUBE` 会生成 2^N 个分组结果，例如 `(region, product, year)` 会有 8 种分组

**辅助函数**

因为小计/总计会把字段填成 `NULL`，有时候你要区分：

* NULL 是数据里真的 NULL
* 还是分组聚合产生的小计

可以用 `GROUPING()`：

```sql
SELECT region, product, SUM(sales),
       GROUPING(region) AS g_region,
       GROUPING(product) AS g_product
FROM orders
GROUP BY CUBE(region, product);
```

`GROUPING(column)` 返回：

* 0，此列参与分组
* 1，此列是聚合产生的 NULL

**自定义汇总**

`GROUPING SETS` 指定多个分组方式，一次性输出

```sql
SELECT region, product, SUM(sales)
FROM orders
GROUP BY GROUPING SETS (
    (region, product),   -- 按区域+产品
    (region),            -- 按区域
    (product),           -- 按产品
    ()                   -- 总和（无分组）
);
```

相当于写了 4 个查询并 `UNION ALL`，Postgres 会帮你合并


### 组合查询

在 PostgreSQL 里用 `UNION`、`INTERSECT`、`EXCEPT` 来把多个 `SELECT` 的结果集合并在一起。它们和集合运算类似

**基本规则**

* 参与的 `SELECT` 必须有相同的列数，且每一列的数据类型必须可以相互兼容
* 默认会自动去重
* 如果你要保留重复行，用 `ALL` 关键字

**UNION**

用途：合并结果，去掉重复行

```sql
SELECT name FROM customers
UNION
SELECT name FROM suppliers;
```

得到两个表里所有名字（重复的只出现一次）

- 保留重复行：

```sql
SELECT name FROM customers
UNION ALL
SELECT name FROM suppliers;
```

- 保留重复记录

**INTERSECT**

- 用途：取两个结果的交集

```sql
SELECT name FROM customers
INTERSECT
SELECT name FROM suppliers;
```

结果是既是客户又是供应商的名字

- 保留重复行：

```sql
SELECT name FROM customers
INTERSECT ALL
SELECT name FROM suppliers;
```

如果某个名字在两边都出现 2 次，就会保留 2 次

**EXCEPT**

用途：取差集（在左边有、右边没有）

```sql
SELECT name FROM customers
EXCEPT
SELECT name FROM suppliers;
```

- 保留重复行：

```sql
SELECT name FROM customers
EXCEPT ALL
SELECT name FROM suppliers;
```

如果某个名字在 `customers` 出现 3 次，在 `suppliers` 出现 1 次，结果会保留 2 次

### VALUES 列表

在 PostgreSQL 里，`VALUES` 列表是一种表表达式，用来直接在 SQL 中构造一张临时表。它可以出现在 `SELECT`、`INSERT` 或 `FROM` 子句中

**基本语法**

```sql
VALUES (expr1, expr2, ...),
       (expr1, expr2, ...),
       ...
```

* 每个小括号 `(...)` 表示一行数据
* 列数必须一致
* 数据类型会自动推断，或者需要显式指定

**最简单的例子**

```sql
VALUES (1, 'Alice'), (2, 'Bob'), (3, 'Carol');
```

输出：

| column1 | column2 |
| ------- | ------- |
| 1       | Alice   |
| 2       | Bob     |
| 3       | Carol   |

**给列起名字**

如果要引用列，需要给临时表命名：

```sql
SELECT *
FROM (VALUES (1, 'Alice'), (2, 'Bob')) AS t(id, name);
```

输出：

| id  | name  |
| --- | ----- |
| 1   | Alice |
| 2   | Bob   |

**用于插入数据**

最常见用途是批量插入数据：

```sql
INSERT INTO users (id, name)
VALUES (1, 'Alice'),
       (2, 'Bob'),
       (3, 'Carol');
```

**用于连接表**

```sql
SELECT u.id, u.name, v.score
FROM users u
JOIN (VALUES (1, 90), (2, 80), (3, 70)) AS v(id, score)
  ON u.id = v.id;
```

这里 `VALUES` 列表相当于一张临时表，可以参与 `JOIN`

**组合**

```sql
SELECT * FROM (VALUES (1), (2), (3)) AS t(x)
UNION
SELECT * FROM (VALUES (2), (3), (4)) AS t(x);
```

得到并集：1,2,3,4

**特殊用法**

* 只取一行常量

```sql
SELECT * FROM (VALUES (now())) AS t(current_time);
```

* 作为 CASE WHEN 的替代写法

```sql
SELECT *
FROM (VALUES ('A', 'Apple'),
              ('B', 'Banana'),
              ('C', 'Cherry')) AS t(code, fruit)
WHERE code = 'B';
```

### 公共表表达式

公用表表达式（**CTE, Common Table Expression**）是 PostgreSQL 里非常重要的查询结构，主要用 `WITH` 语法来定义。它的核心作用是：

* 给复杂查询拆分逻辑，提高可读性
* 类似临时视图，可以被后续查询多次引用
* 可以递归，写层级结构查询

**基本语法**

```sql
WITH cte_name AS (
    SELECT ...
)
SELECT *
FROM cte_name;
```

`cte_name` 就像一个临时表，作用域仅限于这条 SQL

**多个公共表**

```sql
WITH active_users AS (
    SELECT id, name FROM users WHERE active = true
),
big_orders AS (
    SELECT user_id, SUM(amount) AS total
    FROM orders
    GROUP BY user_id
    HAVING SUM(amount) > 1000
)
SELECT u.name, b.total
FROM active_users u
JOIN big_orders b ON u.id = b.user_id;
```

`active_users` 和 `big_orders` 都是临时表，可以在主查询里自由组合

**递归公共表**

递归 CTE 用于层级/树状结构查询，比如员工上下级、目录树

例子：组织架构

```sql
WITH RECURSIVE subordinates AS (
    -- 基础成员（锚点）
    SELECT id, name, manager_id
    FROM employees
    WHERE id = 1   -- 从某个经理开始

    UNION ALL

    -- 递归成员
    SELECT e.id, e.name, e.manager_id
    FROM employees e
    JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates;
```

这个查询会找出 `id = 1` 的员工及其所有下属


**CTE vs 子查询**

* 子查询：只能在 `FROM (...)` 或 `JOIN (...)` 中写，嵌套层级深，可读性差
* CTE：先定义，再引用，更清晰

例子对比：

- 子查询版：

```sql
SELECT u.name, o.total
FROM users u
JOIN (
    SELECT user_id, SUM(amount) AS total
    FROM orders
    GROUP BY user_id
) o ON u.id = o.user_id;
```

- CTE 版：

```sql
WITH order_totals AS (
    SELECT user_id, SUM(amount) AS total
    FROM orders
    GROUP BY user_id
)
SELECT u.name, o.total
FROM users u
JOIN order_totals o ON u.id = o.user_id;
```

**CTE 的执行特性**

* PostgreSQL 12 以前：CTE 是优化屏障，会物化，即先执行完再给主查询用，有时会拖慢性能
* PostgreSQL 12 及以后：非递归 CTE 默认会内联优化，除非用 `MATERIALIZED` 强制物化

```sql
WITH cte AS MATERIALIZED (
    SELECT * FROM big_table
)
SELECT * FROM cte WHERE id < 10;
```

**使用场景**

* 简化复杂 SQL：分步骤写
* 避免重复子查询：一个 CTE 定义，多次用
* 递归查询：树/图遍历
* 调试 SQL：逐步验证逻辑

> 公用表表达式 = 临时视图，让 SQL 更清晰，适合分步骤写复杂逻辑

[返回目录](/README.md)
