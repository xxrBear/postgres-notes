# 字段约束

## 简介
PostgreSQL 中的约束，它是用来保证表数据的完整性和正确性的规则

## 常见约束类型

| 约束类型    | 说明                                       |
| :---------- | :----------------------------------------- |
| NOT NULL    | 列值不能为空                               |
| UNIQUE      | 列值必须唯一，不能重复                     |
| PRIMARY KEY | 唯一标识一行数据，隐含 NOT NULL 和 UNIQUE  |
| FOREIGN KEY | 外键约束，保证引用的列值在另一个表中存在   |
| CHECK       | 自定义条件限制列或多列数据                 |
| EXCLUSION   | 复杂约束，保证两行数据在指定操作符下不冲突 |

## 检查约束
检查约束是最通用的约束类型。它允许您指定某个列中的值必须满足布尔表达式。例如，要要求正的产品价格，您可以使用

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);

```
如果你使用插入语句，插入一个负的`price`，你会得到报错
```sql
INSERT INTO products (product_no, name, price) VALUES (1, 'apple', -1);
```

报错
```
错误:  关系 "products" 的新列违反了检查约束 "positive_price"
DETAIL:  失败, 行包含(1, apple, -1).
```

如果你想修改这个约束的名字，你可以使用`CONSTRAINT`关键字

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
```

## 非空约束

非空约束只是指定列不得采用 null 值。一个语法示例

```sql
CREATE TABLE products (
    product_no integer NOT NULL,
    name text NOT NULL,
    price numeric
);
```

## 唯一约束

唯一约束确保列或一组列中包含的数据在表的所有行中都是唯一的。语法是

```sql
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
```

可以写成列的形式

```sql
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);
```

要为一组列定义唯一约束，请将其写为表约束，列名称用逗号分隔

```sql
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
```

给约束自定义名称

```sql
CREATE TABLE products (
    product_no integer CONSTRAINT must_be_different UNIQUE,
    name text,
    price numeric
);
```

## 主键

主键约束表示列或一组列可以用作表中行的唯一标识符。这要求值既是唯一的又是非空的

```sql
CREATE TABLE products (
    product_no integer PRIMARY KEY,
    name text,
    price numeric
);
```

添加主键会自动在主键中列出的列或列组上创建一个唯一的 B 树索引，并强制将列标记为 NOT NULL

一个表最多只能有一个主键。（可以有任意数量的唯一和非空约束，它们在功能上几乎是相同的，但只能有一个被标识为主键。）关系数据库理论规定每个表都必须有一个主键。 PostgreSQL 不强制执行此规则，但最好遵循它

主键对于文档目的和客户端应用程序都很有用。例如，允许修改行值的 GUI 应用程序可能需要知道表的主键，以便能够唯一地标识行。如果声明了主键，数据库系统也会以各种方式使用它；例如，主键定义了引用其表的外键的默认目标列

## 外键约束

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL,
    CONSTRAINT fk_orders_customer
        FOREIGN KEY (customer_id)
        REFERENCES customers (id)
        ON UPDATE CASCADE
        ON DELETE RESTRICT
);
```

- 级联行为

| 选项          | 父表删除/更新时对子表的影响      |
| :------------ | :------------------------------- |
| `CASCADE`     | 自动删除/更新子表对应行          |
| `RESTRICT`    | 如果被引用，阻止删除/更新        |
| `SET NULL`    | 把子表对应列设为 `NULL`          |
| `SET DEFAULT` | 把子表对应列设为默认值           |
| `NO ACTION`   | 和 `RESTRICT` 类似，只是延迟检查 |

## 排斥约束
```sql
CREATE TABLE reservations (
    reservation_id SERIAL PRIMARY KEY,
    room_id INT NOT NULL,
    -- 定义预定时间范围，使用 tsrange 类型
    time_range TSRANGE NOT NULL,
    reserved_by TEXT
);

-- 添加排斥约束
ALTER TABLE reservations
ADD CONSTRAINT no_overlap_reservation
EXCLUDE USING GIST (
    -- 1. 确保 room_id 必须相等 (=)
    room_id WITH =,
    -- 2. 确保 time_range 不能重叠 (&&)
    time_range WITH &&
);
```
- `USING GIST`: 强制使用 GiST 索引，这是支持范围和几何类型排斥检查所需的索引类型
- `room_id WITH =`: 这告诉 PostgreSQL，只有当两行数据的 room_id 相等时，才需要进行下一步的冲突检查
- `time_range WITH &&`: 这是核心。&& 是范围操作符，表示重叠。这个约束强制要求任何两行数据的 time_range 在 room_id 相等的前提下，不能满足 && 操作符

[返回目录](/README.md)
