# 全文搜索

## 概述
PostgreSQL 的全文搜索并不是简单的 `LIKE` 模糊匹配，它拥有一套完整的语言学处理引擎

其核心原理可以拆解为：文档预处理、分词与标准化、以及倒排索引

### 核心概念

Postgres 全文搜索基于两个核心数据类型：

- `tsvector` (Text Search Vector)：它是预处理后的文档，它会将一段长文本分词，去除无意义的停用词如 "the", "a"，并将单词还原为词干
- `tsquery` (Text Search Query)：它是查询条件，支持逻辑操作，如 `&`, `|`, `!`

### 处理流程

当你执行全文搜索时，Postgres 会经过以下步骤：

1. 分词：将字符串拆分为标记，区分出哪些是单词、数字等
2. 字典处理：标准化把单词统一，例如 "Running" 和 "Ran" 都会变成词根 "run"
3. 停用词过滤：删掉高频但无意义的词如 "is", "of"
4. 生成 `tsvector`：最终形成一个存储词干及其在原文中位置的列表


### 存储原理

这是全文搜索极快的秘密所在 Postgres 通常配合 GIN 倒排索引使用

### 排序原理

搜索结果不仅仅是有或没有，还需要准不准。Postgres 提供了两种内置评分函数：

- `ts_rank`：基于词频，一个词出现的次数越多，权重越高
- `ts_rank_cd`：考虑词与词之间的距离。如果查询的两个关键词靠得很近，权重更高

## 核心对象与术语

- `tsvector`

```sql
SELECT to_tsvector('english', 'The quick brown fox jumped over the lazy dog');
-- 'brown':3 'dog':9 'fox':4 'jump':5 'lazi':8 'quick':2
```

- `tsquery`

```sql
SELECT to_tsquery('english', 'quick & fox');
-- 'quick' & 'fox'
```

- 词典

用于词汇规范化处理，常用内置词典：
- `simple`：按分隔符拆分文本，不进行词形还原
- `english`：支持英语词干提取
- `snowball`：支持多语言词干提取
- `ispell`：词典结合拼写检查
- `synonym`：同义词映射

## 基本操作

**构建文本向量**

```sql
SELECT to_tsvector('english', 'PostgreSQL is a powerful, open source object-relational database system');
```

**构造查询条件**

+ `to_tsquery(config, querytext)`：标准查询构造
+ `plainto_tsquery(config, text)`：将输入文本自动转换为AND组合查询
+ `phraseto_tsquery(config, text)`：短语搜索查询

**匹配查询**

+ **匹配运算符**：`@@`

```sql
SELECT 'fat cats ate rats'::tsvector @@ 'cat & rat'::tsquery;
-- true
```

**结果排序与相关性评分**

+ `ts_rank` / `ts_rank_cd`：计算匹配相关性分数

```sql
SELECT ts_rank_cd(to_tsvector('english', body), to_tsquery('english', 'postgres')) AS rank
FROM articles
ORDER BY rank DESC;
```

**搜索结果高亮**

+ `ts_headline(config, text, query, options)`：返回带高亮标记的文本片段

```sql
SELECT ts_headline('english', 'The quick brown fox', to_tsquery('fox'));
-- The quick brown <b>fox</b>
```

## 索引优化

GIN 索引最适合全文搜索场景，支持大多数查询操作

```sql
CREATE INDEX idx_post_body ON posts USING GIN (to_tsvector('english', body));
```

GiST 索引灵活性更高，但性能通常不如GIN，适用于 `@@`、`@>` 等操作符

## 实践技巧

**搜索建议实现**

+ 结合 trigram (`pg_trgm` 扩展) 实现模糊匹配与全文搜索结合

```sql
CREATE EXTENSION pg_trgm;
SELECT word FROM dictionary ORDER BY word <-> 'postg' LIMIT 5;
```

**增量索引更新**

+ 全文搜索索引不会自动更新 `to_tsvector` 结果，需要使用触发器：

```sql
CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE
ON documents FOR EACH ROW EXECUTE FUNCTION
tsvector_update_trigger(tsv, 'pg_catalog.english', title, body);
```

**JSONB字段搜索**

+ 对JSONB字段也可进行全文搜索：

```sql
CREATE INDEX idx_doc_jsonb_gin ON docs USING GIN (to_tsvector('english', doc->>'content'));
```

## 简单示例

为了让你更直观地看到效果，我们直接在 SQL 模拟一个从创建表到执行全文搜索的全过程

这个示例展示了如何处理词干化，即搜索 `run` 也能搜到 `running` 的原理

首先，我们创建一个简单的博客文章表：

```sql
CREATE TABLE my_posts (
    id SERIAL PRIMARY KEY,
    title TEXT,
    body TEXT
);

INSERT INTO my_posts (title, body) VALUES
('Learning Django', 'Django is a high-level Python Web framework.'),
('PostgreSQL Optimization', 'Indexing and full text search are powerful features in Postgres.'),
('FastAPI Speed', 'FastAPI is running very fast because of its async nature.');
```

然后我们使用 `to_tsvector`（转换文档）和 `to_tsquery`（转换查询条件）进行匹配

```sql
SELECT title, body
FROM my_posts
-- 这里的 'english' 决定了分词规则
WHERE to_tsvector('english', body) @@ to_tsquery('english', 'run & fast');

```

结果分析：即使 `body` 中写的是 "running"，查询条件是 "run"，它依然能匹配成功。这就是全文搜索优于 `LIKE '%run%'` 的地方

你可以运行下面这行命令，看看数据库到底把你的句子变成了什么样：

```sql
SELECT to_tsvector('english', 'FastAPI is running very fast');
-- 'fast':5 'fastapi':1 'run':3
```

* 注意 `running` 变成了 `run`
* `is` 和 `very` 被作为停用词过滤了

在生产环境下，如果表很大，上面的 `WHERE` 子句会逐行计算 `tsvector`，速度极慢。我们需要创建一个索引来存储排好序的词元

```sql
-- 创建一个函数索引
CREATE INDEX idx_fts_body ON my_posts USING GIN (to_tsvector('english', body));
```

如果你想让匹配程度最高的文章排在前面：

```sql
SELECT title, 
       ts_rank(to_tsvector('english', body), query) AS rank
FROM my_posts, to_tsquery('english', 'django | postgres') query
WHERE to_tsvector('english', body) @@ query
ORDER BY rank DESC;

```

[返回目录](/README.md)
