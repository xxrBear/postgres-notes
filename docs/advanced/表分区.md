# 表分区

## 简介

在 PostgreSQL 里，表分区是一种把一张大表按某个规则拆成多个更小、更易管理的分区表的技术，这些分区对用户看起来还是一张表，这样做的核心目的是提高查询性能、减少维护成本，特别是当表非常大时

## 基本原理

* 你定义一个分区表，它是一个逻辑表，自己不存数据
* 每个分区是一张独立的物理表，用于存储符合特定条件的行
* postgres 根据分区键自动把插入的数据路由到对应的分区
* 查询时，PG 会分区裁剪，只扫描相关的分区，减少 I/O

## 分区类型

| 分区方式 | 适用场景               | 示例                               |
| -------- | ---------------------- | ---------------------------------- |
| 范围分区 | 按时间、数值范围拆分   | 按 `order_date` 按月分区           |
| 列表分区 | 按离散值分类           | 按 `region` 分区（华北/华南/华东） |
| 哈希分区 | 均匀分布数据，避免热点 | 按 `user_id` 哈希到 N 个分区       |

## 示例：日期范围分区

```sql
-- 创建父表
CREATE TABLE orders (
    id serial,
    order_date date NOT NULL,
    customer_id int,
    amount numeric
) PARTITION BY RANGE (order_date);

-- 创建分区表
CREATE TABLE orders_2024_q1 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE orders_2024_q2 PARTITION OF orders
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

CREATE TABLE orders_2024_q3 PARTITION OF orders
    FOR VALUES FROM ('2024-07-01') TO ('2024-10-01');
```

查询 `orders` 时，PG 会自动只访问符合条件的分区

## 注意事项

1. 父表不存数据

   * 分区表（父表）是个逻辑表，不能直接 `INSERT` 数据到它
   * 必须通过分区键，让数据落到对应的分区里

2. 主键唯一约束限制

   * 如果父表有 `PRIMARY KEY` 或 `UNIQUE` 约束，分区键必须包含在其中
   * 原因：PostgreSQL 不能跨多个分区检查唯一性

3. 跨分区约束不支持

   * 外键不能跨分区引用父表的数据（PostgreSQL 15 开始对外键支持有增强，但仍有限制）
   * 检查约束（CHECK）只能在分区内生效，不能全局作用

4. 索引是分区本地的

   * 父表上的索引只是一个“模板”，真正的数据索引要在每个分区单独维护
   * 没有“全局索引”，这会影响某些唯一性和查询优化

5. 触发器限制

   * 父表不能有行级触发器（`BEFORE` / `AFTER` ROW），只能在分区上定义
   * 语句级触发器（`STATEMENT`）可以放在父表

6. 不能直接更新分区键

   * 如果更新会导致行移动到另一个分区，会报错，必须先删除再插入

## 权限与安全

* 权限在父表可以设置，但分区也要单独授权

```sql
GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA sales TO analyst;
```

* 适合多租户场景，每个租户一个分区或 schema，权限控制清晰

## 最佳实践

* 时间序列表使用 RANGE 分区最常见，按天、月、季度等
* 哈希分区适合大表且需要均匀分布，但不要单独用来做时间分区
* 选择查询最频繁的列作为分区键
* 尽量避免多列组合分区，组合分区可用，但增加维护复杂度
* 分区键尽量不可更新，更新分区键会导致行迁移，性能差且可能报错

[返回目录](/README.md)
