## 表分区

### 简介
在 postgres 里，表分区是一种把一张大表按某个规则拆成多个更小、更易管理的分区表的技术，这些分区对用户看起来还是一张表

这样做的核心目的是提高查询性能、减少维护成本，特别是当表非常大时

### 基本原理

* 你定义一个分区表，它是一个逻辑表，自己不存数据
* 每个分区是一张独立的物理表，用于存储符合特定条件的行
* postgres 根据分区键自动把插入的数据路由到对应的分区
* 查询时，PG 会分区裁剪，只扫描相关的分区，减少 I/O

### 分区类型

| 分区方式 | 适用场景               | 示例                               |
| -------- | ---------------------- | ---------------------------------- |
| 范围分区 | 按时间、数值范围拆分   | 按 `order_date` 按月分区           |
| 列表分区 | 按离散值分类           | 按 `region` 分区（华北/华南/华东） |
| 哈希分区 | 均匀分布数据，避免热点 | 按 `user_id` 哈希到 N 个分区       |

### 示例：日期范围分区

```sql
-- 创建父表
CREATE TABLE orders (
    id serial,
    order_date date NOT NULL,
    customer_id int,
    amount numeric
) PARTITION BY RANGE (order_date);

-- 创建分区表
CREATE TABLE orders_2024_q1 PARTITION OF orders
    FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');

CREATE TABLE orders_2024_q2 PARTITION OF orders
    FOR VALUES FROM ('2024-04-01') TO ('2024-07-01');

CREATE TABLE orders_2024_q3 PARTITION OF orders
    FOR VALUES FROM ('2024-07-01') TO ('2024-10-01');
```

查询 `orders` 时，PG 会自动只访问符合条件的分区

### 注意事项

- 父表不存数据

   * 分区表（父表）是个逻辑表，不能直接 `INSERT` 数据到它。
   * 必须通过分区键，让数据落到对应的分区里。

- 主键唯一约束限制

   * 如果父表有 `PRIMARY KEY` 或 `UNIQUE` 约束，分区键必须包含在其中。
   * 原因：PostgreSQL 不能跨多个分区检查唯一性（除非用全局唯一索引，但 PG 原生不支持）。

- 跨分区约束不支持

   * 外键不能跨分区引用父表的数据（PostgreSQL 15 开始对外键支持有增强，但仍有限制）
   * 检查约束（CHECK）只能在分区内生效，不能全局作用

- 索引是分区本地的

   * 父表上的索引只是一个“模板”，真正的数据索引要在每个分区单独维护
   * 没有“全局索引”，这会影响某些唯一性和查询优化

- 触发器限制

   * 父表不能有行级触发器（`BEFORE` / `AFTER` ROW），只能在分区上定义
   * 语句级触发器（`STATEMENT`）可以放在父表

- 不能直接更新分区键

   * 如果更新会导致行移动到另一个分区，会报错，必须先删除再插入

### 容易踩坑的细节

以下这些不是硬限制，但会带来性能或维护问题：

**分区数量过多**

   * 每多一个分区，PG 查询规划器的开销会增加（特别是 > 1000 个时）
   * 建议单表分区数控制在几百以内

**分区裁剪依赖常量**

   * 要让 PG 自动裁剪分区，分区键的值最好是常量或能在计划阶段推导出来的表达式
   * 如果是运行时变量（`PREPARE`/`EXECUTE` 传参），需要 PostgreSQL 11+ 才能运行时裁剪

**维护成本高**

   * 新增分区需要显式 `CREATE TABLE ... PARTITION OF ...`
   * 分区的索引、权限、统计信息都是独立的

**统计信息是分区级的**

   * 父表没有整体统计信息（PG 13+ 有一些改进，但不如普通表直观）


### 最佳实践

* 时间序列表使用 RANGE 分区最常见（按天、按月、按季度）
* 哈希分区适合大表且需要均匀分布，但不要单独用来做时间分区
* 选择查询最频繁的列作为分区键
* 尽量避免多列组合分区
  * 组合分区（如 RANGE+HASH）可用，但增加维护复杂度
* 分区键尽量不可更新
  * 更新分区键会导致行迁移，性能差且可能报错

**索引要在分区上单独创建**
  * 父表的索引只作为模板，不会存数据
  * 可考虑为每个分区建立索引，减少索引维护压力

**主键与唯一约束**
  * 必须包含分区键，否则无法跨分区保证唯一性
  * 如果需要全局唯一，可以使用触发器或逻辑层保证

**创建自动化脚本或者调度任务**
  * 定期创建新分区
  * 删除或归档过期分区
  * 统计分区信息

### 权限与安全

* 权限在父表可以设置，但分区也要单独授权

```sql
GRANT SELECT, INSERT ON ALL TABLES IN SCHEMA sales TO analyst;
```

* 适合多租户场景，每个租户一个分区或 schema，权限控制清晰

[返回目录](#目录)