# 索引

## 简介

如果你要执行以下的SQL
```sql
SELECT content FROM test1 WHERE id = constant;
```

在没有索引的情况下，系统会扫描表里的每一条数据，以找到匹配的条目，如果test1表巨大，而数据却只有几条，那么这无疑是一个很低效的方法。但是，如果系统被指示在 id 列上维护索引，它可以使用更有效的方法来定位匹配的行。当它认为这样做比顺序表扫描更有效时，它将在查询中使用索引

索引还可以使带有搜索条件的 UPDATE 和 DELETE 命令受益。索引还可以用于连接搜索。因此，在作为连接条件一部分的列上定义的索引也可以显着加快带有连接的查询

要合理的设计和使用索引，不能盲目的使用，索引并非没有缺点。例如，在大表上创建索引可能需要很长时间。默认情况下，postgres 允许在创建索引的同时对表进行读取（SELECT 语句），但写入（INSERT，UPDATE，DELETE）将被阻塞，直到索引构建完成。在生产环境中，这通常是不可接受的

## 索引类型

| 索引类型 | 适用场景/优点                                                                    | 常用操作符                                          | 是否支持排序 | 是否支持唯一约束 |
| -------- | -------------------------------------------------------------------------------- | --------------------------------------------------- | ------------ | ---------------- |
| B-tree   | 默认索引类型，适用于大多数比较操作，如 `=`, `<`, `>`, `BETWEEN`, `LIKE` 前缀匹配 | `=`, `<`, `>`, `<=`, `>=`, `BETWEEN`, `LIKE 'abc%'` | 支持         | 支持             |
| Hash     | 仅用于等值查询，例如 `WHERE col = value`。性能略快于 B-tree，但功能受限          | `=`                                                 | 不支持       | 不支持           |
| GIN      | 多值字段，如数组、JSONB、全文检索（`to_tsvector`）                               | `@>`, `<@`, `?`, `@@` 等                            | 不支持       | 不支持           |
| GiST     | 空间数据（PostGIS）、全文检索、模糊搜索、自定义数据类型                          | 取决于实现（如 k-NN）                               | 不支持       | 不支持           |
| SP-GiST  | 稀疏数据、高维数据、分布不均的字段（如IP地址、文本前缀树）                       | 特定操作符                                          | 不支持       | 不支持           |
| BRIN     | 特别适合大表的顺序插入列（如时间戳），体积小，查询范围效率高                     | 依赖顺序扫描                                        | 不支持       | 不支持           |

## 表达式索引

在 postgres 中，表达式索引是一种特殊形式的索引，它不是直接建立在某个列上，而是建立在列的计算结果上

```sql
CREATE INDEX idx_lower_name ON users (lower(name));
```
这个索引会存储 lower(name) 的结果，适用于你经常在查询中写 WHERE lower(name) = 'xxx' 的情况

## 部分索引

在 postgres 中，部分索引是一种只对表中部分行建立的索引

举个例子：

假设你有一个 `users` 表，100 万条用户记录，其中只有 5 万用户是活跃的 `active = true`

如果你这样建了一个普通索引：

```sql
CREATE INDEX idx_all_users_email ON users(email);
```

这个索引会包含全部 100 万行的 email 信息 —— 体积大，查询时还得配合 `active = true` 过滤数据

但如果你建部分索引：

```sql
CREATE INDEX idx_active_users_email ON users(email) WHERE active = true;
```

这个索引只包含那 5 万条活跃用户的 email，因此：

* 索引所占用体积更小、查询速度更快
* 查询 `WHERE active = true AND email = 'xxx'` 时，能直接走这部分索引
* 对剩下的 95 万不活跃用户完全不走索引，省资源

## 仅索引扫描和覆盖索引

仅索引扫描的和覆盖索引是重要的知识，熟悉它们是写出高效SQL查询语句的关键。但是在聊他两之前，我们还需要一些前置知识

**postgres 的存储结构**

postgres 的表和索引都是通过文件系统中的物理文件来存储的。每一个数据库对象（如表、索引等）都有自己的物理文件，文件结构和访问机制体现了 postgres 的核心架构理念

postgres 默认采用堆表作为表的物理存储结构，它的核心特点是：数据以无特定顺序的形式直接存储在磁盘上的数据页中，每一行都独立存储，并通过一个唯一的行指针定位

**什么是回表**

回表指的是：

> 查询时先通过索引定位到匹配的行，但由于需要返回的字段不在索引中，因此还需要再访问一次原表来获取完整的数据

举个例子：

假设有如下表：

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT,
    age INT,
    email TEXT
);
```

并且建立了一个索引：

```sql
CREATE INDEX idx_users_name ON users(name);
```

然后你执行以下查询：

```sql
SELECT email FROM users WHERE name = 'Alice';
```

- 数据库会使用 `idx_users_name` 索引找到 `name='Alice'` 的所有行的位置，也就是行指针
- 由于 `email` 不包含在这个索引里，所以数据库需要根据这些指针再去原表中回表查询 `email` 字段的值

回表的代价

回表相当于多了一次随机磁盘读取或内存页访问，会增加查询的开销，尤其在匹配行较多的情况下

仅索引扫描和覆盖索引的目的都是减少SQL查询时的磁盘随机读取

仅索引扫描的目的是减少回表查询，我们不要查询的字段未设置索引的字段，而覆盖索引是一种设计方法，我们把我们需要查询的字段都添加索引

查看执行计划

要确定你的查询语句是否是仅索引扫描或覆盖索引，可以使用`explain analyze` 语句查看执行计划

```sql
EXPLAIN ANALYZE
SELECT col1 FROM my_table WHERE col2 = 'foo';
```

查看结果中是否有`Index Only Scan using my_index on my_table`等语句

## 索引排序

除了简单地查找查询要返回的行之外，索引还可以按特定的排序顺序返回这些行。这使得查询的 ORDER BY 规范可以在不进行单独排序步骤的情况下得到满足。在 PostgreSQL 当前支持的索引类型中，只有 B-tree 能够产生排序输出——其他索引类型返回匹配的行时，顺序是不确定的、依赖于实现的。

默认情况下，B-tree 索引按升序存储其条目，NULL 值排在最后。这意味着对列 x 的索引进行正向扫描会产生满足 ORDER BY x 的输出。索引也可以反向扫描，产生满足 ORDER BY x DESC 的输出

- 创建
```sql
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
```

## 唯一索引
目前，只有 B-tree 索引可以声明为唯一

当一个索引被声明为唯一时，不允许具有相同索引值的多行表记录。默认情况下，唯一列中的 NULL 值不被视为相等，因此允许该列中有多个 NULL。 `NULLS NOT DISTINCT` 选项会修改此行为，使索引将 NULL 值视为相等。多列唯一索引只会拒绝多个行中所有索引列都相同的组合。
```sql
CREATE UNIQUE INDEX name ON table (column [, ...]);
```


## 如何选择合适的索引

| 类型   | 用途                 |
| ------ | -------------------- |
| B-Tree | 默认，80% 场景       |
| Hash   | 等值查询             |
| GIN    | jsonb / array / 全文 |
| GiST   | 范围、地理           |
| BRIN   | 超大表、时间序列     |


[返回目录](/README.md)