## 数据库维护

### 简介

PostgreSQL 数据库需要定期维护和清理。对于大多数安装环境来说，自动清理守护进程通常就能完成这项工作。不过，你可能需要根据具体情况调整相关参数，以获得最佳效果。

有些数据库管理员希望通过手动执行 VACUUM 命令，来补充或替代自动清理守护进程的工作，这通常通过 cron 或任务计划程序定时执行。要正确设置手动清理，需要理解以下几个小节中介绍的相关问题。即使依赖自动清理的管理员，也建议阅读这些内容，以便更好地理解和优化自动清理的行为。

### 基础
PostgreSQL 的 VACUUM 命令需要定期对每个表执行，其原因包括：

- 回收或重用被更新或删除的行占用的磁盘空间
- 更新查询优化器使用的数据统计信息
- 更新可见性映射，以加快仅使用索引的扫描
- 防止事务 ID 回绕（或多事务 ID 回绕）导致非常旧的数据丢失

正如后续小节将详细说明的那样，每个原因可能需要不同频率和范围的 VACUUM 操作。

VACUUM 有两种形式：标准 VACUUM 和 VACUUM FULL。

VACUUM FULL 可以回收更多磁盘空间，但执行速度慢，并且会对表加 ACCESS EXCLUSIVE 锁，因此无法与其他操作并行进行。

标准 VACUUM 执行时可以与生产数据库中的其他操作并行运行（如 SELECT、INSERT、UPDATE、DELETE 等），虽然在使用诸如 ALTER TABLE 修改表结构时仍然有限制。

因此，一般建议管理员优先使用标准 VACUUM，尽量避免 VACUUM FULL，除非确实需要大幅回收空间。

此外，VACUUM 会产生大量 I/O，可能影响其他会话的性能。可以通过调整相关配置参数来减轻后台清理对性能的影响，从而在保证数据库健康的同时降低对生产负载的干扰。

### 回收磁盘空间
在 PostgreSQL 中，行的 UPDATE 或 DELETE 操作不会立即删除旧版本。这是多版本并发控制（MVCC）所必需的：当其他事务仍可能访问该行版本时，旧版本不能被删除。然而，最终那些过时或已删除的行版本不再被任何事务引用，其占用的空间必须回收以供新行重用，否则磁盘空间会无限增长。VACUUM 命令正是用来完成这一任务的。

标准 VACUUM 会删除表和索引中的死行版本，并将空间标记为可重用，但通常不会将空间返回给操作系统，除非表末尾的一个或多个页面完全空闲且可安全获得独占锁。相比之下，VACUUM FULL 会生成表的新副本，去除所有死空间，从而最大程度压缩表大小。但它执行时间长，并且需要额外的磁盘空间来存放新副本，直到操作完成。

日常维护的目标通常是频繁运行标准 VACUUM，以避免使用 VACUUM FULL。自动清理守护进程就是按照这种思路工作的，它几乎从不执行 VACUUM FULL。这种方式关注的是保持磁盘空间的稳定使用：每个表占用的空间约为其最小大小，加上两次清理运行之间产生的空间。虽然 VACUUM FULL 可以将表缩小到最小并释放磁盘空间，但如果表随后还会增长，这种操作意义不大。因此，对于经常更新的表，频繁运行标准 VACUUM 比偶尔运行 VACUUM FULL 更有效。

一些管理员喜欢自行安排清理，例如在夜间负载较低时执行。但固定时间表的清理可能面临问题：如果某表的更新活动意外激增，表可能膨胀到必须使用 VACUUM FULL 才能回收空间。自动清理守护进程能够动态响应表的更新活动，从而缓解这一问题。因此，除非工作负载非常可预测，否则完全禁用自动清理是不明智的。一种折衷方案是调整守护进程参数，使其仅在更新活动异常繁重时才触发清理，同时依靠计划的 VACUUM 在负载正常时完成大部分工作。

对于未使用自动清理的用户，常见做法是在低使用率时段每天执行一次全库 VACUUM，并根据需要对高频更新表进行更频繁的清理。有些更新量极高的系统甚至会每隔几分钟清理最繁忙的表。如果集群中存在多个数据库，记得对每个数据库都执行 VACUUM。工具 vacuumdb 在这种情况下非常有用。

### 索引重建

在某些情况下，定期使用 REINDEX 命令或通过一系列步骤重建索引是值得的。

对于 B 树索引，完全空的索引页会被回收以供重用，但仍可能存在空间使用效率低下的情况：如果一个页面上除了少数几个索引键之外的所有键都被删除，该页面仍会被分配。也就是说，如果一个范围内的大部分键被删除，但不是全部，被分配的页面仍然存在，从而导致空间浪费。在这种使用模式下，定期重建索引可以改善空间利用率。

对于 非 B 树索引，其膨胀情况尚未得到充分研究。因此，在使用其他类型索引时，定期监控索引的物理大小是一个良好的做法。

此外，对于 B 树索引，新构建的索引通常比经历多次更新的索引访问速度更快。这是因为逻辑上相邻的页面在新建索引中往往也是物理上相邻的，从而提高了访问效率（非 B 树索引不具备此特性）。因此，定期重建索引有时也可以作为性能优化手段。

REINDEX 命令在任何情况下都是安全且易用的。默认情况下，它需要 ACCESS EXCLUSIVE 锁，但通常更推荐使用 CONCURRENTLY 选项执行，此选项仅需 SHARE UPDATE EXCLUSIVE 锁，从而对并发操作的影响更小。


### 日志文件维护

建议将数据库服务器的日志输出保存到指定位置，而不是直接丢弃到 `/dev/null`。日志对于排查问题和诊断异常非常重要。

> 服务器日志可能包含敏感信息，需要妥善保护，无论其存储方式、存储位置或传输目的地。例如，某些 DDL 语句可能包含明文密码或其他身份验证信息；在 ERROR 级别记录的语句可能暴露应用程序的 SQL 源码，甚至包含部分数据行。记录这些信息是日志功能的预期行为，因此不应视为泄露或错误。请确保日志仅对经过授权的人员可见。

日志输出往往很大（尤其是在高调试级别下），因此不宜无限期保存。需要轮换日志文件，以便定期启动新日志文件并删除旧文件。

如果仅将 `postgres` 的 stderr 重定向到文件，可以获得日志输出，但截断日志文件的唯一方法是停止并重启服务器。对于开发环境可能可行，但生产环境通常无法接受。

更好的方法是将服务器 stderr 输出发送到日志轮换程序。PostgreSQL 内置了日志轮换工具，可通过在 `postgresql.conf` 中将 `logging_collector` 设置为 `true` 启用。该工具的配置参数详见文档第 19.8.1 节，并支持以 CSV 格式生成机器可读日志。

如果系统中已经使用其他日志轮换程序，也可以结合使用。例如，Apache 发行版中包含的 `rotatelogs` 可与 PostgreSQL 配合，将服务器 stderr 通过管道传输到它：

```bash
pg_ctl start | rotatelogs /var/log/pgsql_log 86400
```

你还可以结合使用 PostgreSQL 内置日志收集器和 `logrotate`：日志收集器负责生成日志文件及其路径，`logrotate` 定期归档。启动日志轮换时，`logrotate` 通过 `postrotate` 脚本向服务器发送 **SIGHUP** 信号，使服务器切换到新的日志文件或重新打开现有文件。PostgreSQL 可使用 `pg_ctl` 配合 logrotate 实现此操作，具体取决于日志配置。

> 使用静态日志文件名时，如果达到系统的最大打开文件数或发生文件表溢出，服务器可能无法重新打开日志文件，导致日志继续写入旧文件。如果 logrotate 配置了压缩并删除日志文件，可能会丢失该时间段的日志。为避免此问题，可使用动态日志文件名，并通过 `prerotate` 脚本处理打开的日志文件。

另一种生产环境推荐做法是将日志发送到 **syslog**，由 syslog 处理轮换。在 `postgresql.conf` 中设置 `log_destination = 'syslog'` 即可。此时，可向 syslog 守护进程发送 **SIGHUP** 信号强制写入新日志文件，同时可用 logrotate 配合 syslog 日志实现自动轮换。

需要注意，syslog 在处理大量日志消息时可靠性可能不高，可能会截断或丢失消息；在 Linux 系统上，syslog 默认每条消息都会同步写入磁盘，可能影响性能（可通过在配置文件中在文件名开头加 `-` 禁用同步）。

所有上述方法都可以定期生成新的日志文件，但不会自动删除旧日志。建议设置批处理任务定期删除过期日志，或配置轮换程序循环覆盖旧日志。

此外，还有一些外部工具可增强日志管理和分析功能：

* **pgBadger**：用于复杂日志分析，生成可视化报告
* **check_postgres**：可检测日志中重要消息并生成 Nagios 警报，同时监控其他异常情况

[返回目录](/README.md)