## 预写式日志

### 简介

预写式日志 (WAL) 是一种确保数据完整性的标准方法。绝大多数关于事务处理的书籍中都可以找到详细描述。简而言之，WAL的核心概念是，只有在对数据文件（表和索引所在的位置）的更改被记录下来之后，即在描述更改的 WAL 记录被刷新到永久存储之后，才能写入这些更改。如果我们遵循此过程，我们就不需要在每次事务提交时都将数据页刷新到磁盘，因为我们知道，在发生崩溃时，我们将能够使用日志恢复数据库：任何尚未应用于数据页的更改都可以从 WAL 记录中重做。这是前滚恢复，也称为 REDO

> [!Tip]
>因为WAL在崩溃后恢复数据库文件内容，所以对于数据文件或 WAL 文件的可靠存储来说，日志文件系统不是必需的。事实上，日志开销可能会降低性能，尤其是当日志记录导致文件系统数据被刷新到磁盘时。幸运的是，通常可以通过文件系统挂载选项禁用日志记录期间的数据刷新，例如，Linux ext3 文件系统上的 data=writeback。日志文件系统确实可以提高崩溃后的启动速度

使用 WAL 可以显著减少磁盘写入次数，因为为了保证事务被提交，只需要将 WAL 文件刷新到磁盘，而不是每次事务更改的数据文件都刷新到磁盘。WAL 文件是顺序写入的，因此同步 WAL 的成本远低于刷新数据页的成本。对于处理许多接触数据存储不同部分的小型事务的服务器来说尤其如此。此外，当服务器处理许多小型并发事务时，一次 fsync WAL 文件可能足以提交许多事务。

WAL也使得支持在线备份和时间点恢复成为可能。通过归档 WAL 数据，我们可以支持恢复到可用 WAL 数据覆盖的任何时间点：我们只需安装数据库的先前物理备份，并重放 WAL 到所需时间即可。更重要的是，物理备份不必是数据库状态的瞬时快照 — 如果它是在一段时间内制作的，那么重放该期间的 WAL 将修复任何内部不一致性

### 可靠性

可靠性是数据库系统的核心特性之一，PostgreSQL 尽最大努力确保可靠运行

可靠性的一个关键方面是：已提交事务的数据必须写入非易失性存储，以避免因断电、操作系统崩溃或硬件故障而丢失（非易失性存储本身的故障除外）。通常，只要数据被成功写入永久存储（如磁盘或等效设备），这一要求就能得到满足

实际上，即便计算机本身遭受致命损坏，只要磁盘仍然完好，就可以将其转移到另一台硬件相似的计算机中，所有已提交事务的数据依然能够完整保留

### 异步提交

异步提交是一种允许事务更快完成的选项，其代价是如果数据库崩溃，则最近的事务可能会丢失。在许多应用程序中，这是一个可以接受的权衡，如果你的业务对于数据完整性的要求没有那么的严格

如上一节所述，事务提交通常是同步的：服务器在将事务的 WAL 记录刷新到永久存储之前，会等待，然后再向客户端返回成功指示。因此，即使在服务器立即崩溃的情况下，客户端也可以保证报告已提交的事务会被保留。但是，对于短事务，这种延迟是总事务时间的主要组成部分。选择异步提交模式意味着服务器在事务逻辑完成时立即返回成功，在它生成的WAL记录实际写入磁盘之前。这可以为小事务提供显着的吞吐量提升

异步提交引入了数据丢失的风险。在向客户端报告事务完成和事务真正提交（即，如果服务器崩溃，保证不会丢失）之间存在一个很短的时间窗口。因此，如果客户端将采取依赖于事务将被记住的假设的外部操作，则不应使用异步提交。例如，银行肯定不会将异步提交用于记录 ATM 机取款的交易。但在许多场景中，例如事件日志记录，不需要这种强大的保证。

使用异步提交所承担的风险是数据丢失，而不是数据损坏。如果数据库崩溃，它将通过重放 WAL 到最后刷新的记录来恢复。因此，数据库将被恢复到自洽状态，但任何尚未刷新到磁盘的事务都不会反映在该状态中。因此，最终效果是丢失最后几个事务。由于事务按提交顺序重放，因此不会引入不一致性——例如，如果事务 B 进行了依赖于先前事务 A 的效果的更改，则不可能在保留 B 的效果的同时丢失 A 的效果。

用户可以选择每个事务的提交模式，以便可以同时运行同步和异步提交事务。这允许在性能和事务持久性的确定性之间进行灵活的权衡。提交模式由用户可设置的参数 synchronous_commit 控制，该参数可以以任何配置参数可以设置的方式更改。任何一个事务使用的模式取决于事务提交开始时 synchronous_commit 的值。

某些实用程序命令，例如 DROP TABLE，无论 synchronous_commit 的设置如何，都强制同步提交。这是为了确保服务器的文件系统和数据库的逻辑状态之间的一致性。支持两阶段提交的命令（例如 PREPARE TRANSACTION）也始终是同步的。

如果数据库在异步提交和写入事务的WAL记录之间的风险窗口内崩溃，那么该事务期间所做的更改将会丢失。风险窗口的持续时间是有限的，因为后台进程（“WAL 写入器”）每 wal_writer_delay 毫秒将未写入的WAL记录刷新到磁盘。风险窗口的实际最大持续时间是 wal_writer_delay 的三倍，因为 WAL 写入器被设计为在繁忙期间倾向于一次写入整个页面。

> [!Warning]
> 立即模式关闭等同于服务器崩溃，因此会导致任何未刷新的异步提交丢失

异步提交提供的行为与设置 fsync = off 不同。fsync 是一个服务器范围的设置，它会改变所有事务的行为。它禁用 PostgreSQL 中所有尝试将写入同步到数据库不同部分的逻辑，因此，系统崩溃（即硬件或操作系统崩溃，而不是 PostgreSQL 本身故障）可能会导致数据库状态的任意严重损坏。在许多场景中，异步提交提供了可以通过关闭 fsync 获得的大部分性能提升，但没有数据损坏的风险。

commit_delay 听起来也很像异步提交，但它实际上是一种同步提交方法（实际上，在异步提交期间会忽略 commit_delay）。commit_delay 会在事务刷新WAL到磁盘之前造成延迟，希望一个这样的事务执行的单个刷新也可以服务于大约在同一时间提交的其他事务。该设置可以被认为是增加事务可以加入即将参与单个刷新的组的时间窗口，以分摊多个事务之间的刷新成本的一种方法

### 配置

**WAL 工作机制**

预写式日志是 PostgreSQL 保证事务一致性和崩溃恢复的核心

1. **修改数据时**：先写 WAL，再写共享缓冲区
2. **事务提交时**：WAL 必须 fsync 落盘才算提交成功（除非 `synchronous_commit=off`）
3. **后台进程**：
   * WAL Writer：负责周期性写 WAL 文件，减少事务提交时的 fsync 压力
   * Checkpointer：将脏页刷回数据文件，减少崩溃恢复时需要重放的 WAL 数量
   * Archiver：如果开启归档，会把完成的 WAL 段文件存储到安全位置
   * WAL Sender / Receiver：用于流复制

**WAL 参数详细解读**

- 基础控制

| 参数                 | 取值                                          | 说明                    | 场景                                                            |
| -------------------- | --------------------------------------------- | ----------------------- | --------------------------------------------------------------- |
| `wal_level`          | `minimal` / `replica` / `logical`             | 控制 WAL 记录的详细程度 | `replica`：主从复制；`logical`：逻辑复制；`minimal`：仅本地恢复 |
| `fsync`              | on/off                                        | 是否强制刷盘            | 一般必须 `on`，否则掉电丢数据                                   |
| `synchronous_commit` | on/off/remote_apply/remote_write/remote_flush | 提交时的 WAL 刷盘策略   | `on` 安全，`off` 快但可能丢几 ms 数据                           |


- 空间与内存

| 参数               | 默认            | 说明                                | 调优                    |
| ------------------ | --------------- | ----------------------------------- | ----------------------- |
| `wal_segment_size` | 16MB            | 单个 WAL 文件大小，编译时固定       | 编译时可改为 64MB/256MB |
| `wal_buffers`      | -1（通常 16MB） | WAL 写入的共享内存缓存              | 高并发写场景调到 64MB+  |
| `max_wal_size`     | 1GB             | 自动 checkpoint 前允许的 WAL 最大量 | OLTP 可设 4–8GB         |
| `min_wal_size`     | 80MB            | checkpoint 后保留的 WAL 空间        | 建议 512MB–1GB          |


- 写入与延迟

| 参数                     | 默认  | 说明                                      | 调优                                 |
| ------------------------ | ----- | ----------------------------------------- | ------------------------------------ |
| `wal_writer_delay`       | 200ms | WAL Writer 写入频率                       | 可以调小（50–100ms）降低 commit 卡顿 |
| `wal_writer_flush_after` | 1MB   | 累积多少字节后强制刷盘                    | 高 IOPS 环境可设 2–4MB               |
| `commit_delay`           | 0     | 提交时延迟（μs），允许更多事务合并        | 在高并发下可设 50–200 μs             |
| `commit_siblings`        | 5     | 并发事务数达到多少时才启用 `commit_delay` | OLTP 可设 10–20                      |


- 归档与备份

| 参数              | 默认 | 说明                        | 示例                                       |
| ----------------- | ---- | --------------------------- | ------------------------------------------ |
| `archive_mode`    | off  | 是否启用归档                | `on` or `always`                           |
| `archive_command` | 空   | 每个 WAL 文件完成时执行命令 | `test ! -f /backup/%f && cp %p /backup/%f` |
| `archive_timeout` | 0    | 即使未写满也切换 WAL 的时间 | 建议 60s，保证 PITR 恢复及时               |


- 复制与高可用

| 参数                    | 默认 | 说明                                 |
| ----------------------- | ---- | ------------------------------------ |
| `max_wal_senders`       | 10   | 最大 WAL sender 数量（流复制通道数） |
| `wal_keep_size`         | 0    | 保留多少 WAL 供从库追赶              |
| `max_replication_slots` | 10   | 逻辑/物理复制槽数量                  |
| `hot_standby`           | on   | 从库是否可读                         |
| `primary_conninfo`      | 空   | 从库连接主库的信息                   |

**场景化配置最佳实践**

- OLTP（高并发交易系统）

```conf
wal_level = replica
synchronous_commit = on
wal_compression = on
wal_buffers = 64MB
max_wal_size = 8GB
min_wal_size = 1GB
wal_writer_delay = 50ms
commit_delay = 100
commit_siblings = 20
```

适合高并发写，保证安全和性能平衡

- 数据仓库 / 批量导入

```conf
wal_level = minimal
synchronous_commit = off
wal_compression = off
wal_buffers = 32MB
max_wal_size = 16GB
```

追求吞吐量，牺牲部分安全

- 流复制主库

```conf
wal_level = replica
archive_mode = on
archive_command = 'rsync -a %p standby:/wal_archive/%f'
max_wal_senders = 10
max_replication_slots = 10
wal_keep_size = 2GB
```

保证从库能及时追上，避免 WAL 丢失


- 逻辑复制

```conf
wal_level = logical
max_replication_slots = 20
max_wal_senders = 20
wal_keep_size = 4GB
```

适合消息队列同步、异构系统

**常见问题与调优思路**

WAL 占用太大

* 检查 `max_wal_size` 是否过大
* 看 `archive_command` 是否失败（堆积）
* 复制槽是否未消费（逻辑复制常见）

提交性能差

* 检查 `synchronous_commit`，必要时用 `off`
* 增大 `wal_buffers`
* 调整 `wal_writer_delay`
* 用 `commit_delay` 聚合提交

归档不及时

* 设置 `archive_timeout`（比如 60s）
* 确认归档目录有空间

复制延迟大

* 增加 `wal_keep_size`
* 检查从库 `max_standby_streaming_delay` 设置
* 优化主库磁盘 IO

### 内部结构

启用与基本原理

* WAL 默认自动启用，无需额外配置
* 管理员只需确保磁盘空间充足，并根据需要调整相关参数
* WAL 的核心思想：先写日志，再写数据文件，确保崩溃后可恢复

WAL 记录与 LSN

* WAL 记录以 **追加方式**写入 `pg_wal/` 目录中的日志文件
* **插入位置**由日志序列号（LSN, Log Sequence Number）标识

  * LSN 是 WAL 文件中的字节偏移量，单调递增
  * PostgreSQL 提供 `pg_lsn` 数据类型存储 LSN，可比较两个值以计算 WAL 数据量差异
  * 常用于 **复制进度和恢复进度** 的度量

WAL 文件组织

  * WAL 文件存放在 `pg_wal/` 目录下，以段文件的形式存在：

    * 默认大小：**16MB**（可通过 `--wal-segsize` 在 `initdb` 时修改）
    * 每个段被分为 **8KB 页**（可通过 `--with-wal-blocksize` 修改）
  * 段文件命名方式：不断递增的十六进制编号，如 `000000010000000000000001`，不会回绕
  * WAL 记录头定义在 `access/xlogrecord.h`，记录内容依赖事件类型

存储优化

  * 将 `pg_wal/` 目录移动到独立磁盘上，并通过符号链接指向新位置，可提升性能（需要在关闭服务器时操作）


潜在风险

* 理论上 WAL 保证“日志先于数据写入”，但部分磁盘可能只将数据写入缓存，未真正落盘，却向内核错误报告成功写入
* 若此时断电，可能造成数据无法恢复
* 管理员建议：确保存储 PostgreSQL WAL 的磁盘可靠，避免此类虚假写入确认

检查点与恢复

* 每次检查点完成后，其位置会写入 `pg_control` 文件
* 恢复时流程：

  1. 读取 `pg_control` 获取最近的检查点信息
  2. 从检查点位置开始向前扫描 WAL 并执行 REDO
  3. 因为 WAL 保存了检查点之后所有修改的完整页面（若启用 `full_page_writes`），所以能恢复到一致状态


pg_control 的潜在弱点

* 若 `pg_control` 损坏，理论上应支持从 WAL 文件中逆向扫描找到最新检查点，但该功能尚未实现
* 实际上：
  * `pg_control` 文件非常小（不足一页），基本不会出现部分写入问题
  * 迄今未发生因 `pg_control` 损坏而导致数据库无法恢复的案例
* 因此，这一弱点仅存在于理论层面

[返回目录](/README.md)
